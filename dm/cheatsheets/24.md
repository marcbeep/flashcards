---
## **The Apriori Algorithm – Summary**

### **1. Goal**

To find **frequent itemsets** in a dataset of transactions, based on a minimum **frequency threshold**.
---

### **2. Key Concepts**

#### **Itemset**

A group of items that might appear together in a transaction.

#### **Support of an itemset (sup(I))**

The number of transactions in which itemset **I** appears.

#### **Frequent itemset**

An itemset whose support is **greater than or equal** to a threshold **f**.

---

### **3. Brute Force Approach (Improved)**

Given:

- **U**: Universe of items
- **𝒟**: Dataset (a list of transactions)
- **f**: Frequency threshold

Steps:

1. For each **k** from 1 to |U|:
2. For every possible itemset **I** of size **k**:

   - Calculate **sup(I)** (support).
   - If **sup(I) ≥ f**, add **I** to frequent itemsets.

3. If no itemsets of size **k** are frequent, STOP.

🧠 **Problem**: Checking support for every possible combination is expensive.

---

### **4. Apriori Algorithm – Core Idea**

Avoid checking all combinations by using the **Downward Closure Property**:

> If an itemset is frequent, then **all its subsets** are also frequent.

So:

- Skip generating itemsets that have infrequent subsets.
- Only consider itemsets built from **frequent smaller itemsets**.

---

### **5. Definitions Used**

- **ℱₖ**: Set of frequent itemsets of size **k**
- **𝒞ₖ**: Set of candidate itemsets of size **k**

---

### **6. Apriori Algorithm – Steps**

Given:

- **U**: Universe of items
- **𝒟**: Dataset of transactions
- **f**: Frequency threshold

1. Compute **ℱ₁** (frequent 1-itemsets)
2. For **k = 2 to d** (max itemset size):

   - If **ℱₖ₋₁** is empty → break
   - Generate candidate itemsets **𝒞ₖ** from **ℱₖ₋₁**
   - For each **I ∈ 𝒞ₖ**, if **sup(I) ≥ f**, add **I** to **ℱₖ**

3. Return all **frequent itemsets** (the union of all **ℱᵢ**)

---

### **7. Assumptions**

- **U = {1, 2, ..., d}** (items are numbered)
- Itemsets are ordered subsets of **U**
- Transactions are ordered lexicographically (e.g. {1, 2, 3})

#### **Example Dataset (ordered)**

```
{1, 2, 4}
{1, 3, 4}
{1, 3, 5}
{1, 2, 5}
{2, 2, 3}
```

---

### **8. Downward Closure Property – Details**

Let **I = {j₁, j₂, ..., jₖ} ∈ ℱₖ** (a frequent k-itemset). Then:

1. Every subset of size **(k−1)** is also frequent.
2. **I** can be **created by joining** two itemsets from **ℱₖ₋₁**:

   - `{j₁, j₂, ..., jₖ₋₁}` and
   - `{j₁, j₂, ..., jₖ₋₂, jₖ}`

So:
👉 We only keep **I** in candidates if it can be formed by joining two valid (k−1)-itemsets.

---

### **9. Candidate Generation (generate-candidates)**

**Input**:

- **ℱ**: Set of frequent itemsets of size **k**
- **k**: Current itemset size

#### **Join Phase**

1. Assume items in **ℱ** are ordered
2. For each **I ∈ ℱ**, where **I = {j₁, ..., jₖ₋₁}**:

   - For each **j = jₖ₋₁ + 1 to d**:

     - Create **I′ = {j₁, ..., jₖ₋₂, j}**
     - If **I′ ∈ ℱ**, then form candidate **I ∪ {j}** and add to **𝒞**

#### **Prune Phase**

1. For each **I ∈ 𝒞**:

   - For each **j ∈ I**:

     - If **I - {j} ∉ ℱ**, remove **I** from 𝒞 (since one subset is not frequent)

---

### **10. Example Summary**

- **Frequent itemsets**: itemsets that appear frequently in transactions.
- **Non-frequent itemsets**: do not meet the frequency threshold.
- **Generated candidates**: possible frequent itemsets from joining.
- **Pruned candidates**: removed because some subset was not frequent.

---
