---
## **The Apriori Algorithm â€“ Summary**

### **1. Goal**

To find **frequent itemsets** in a dataset of transactions, based on a minimum **frequency threshold**.
---

### **2. Key Concepts**

#### **Itemset**

A group of items that might appear together in a transaction.

#### **Support of an itemset (sup(I))**

The number of transactions in which itemset **I** appears.

#### **Frequent itemset**

An itemset whose support is **greater than or equal** to a threshold **f**.

---

### **3. Brute Force Approach (Improved)**

Given:

- **U**: Universe of items
- **ğ’Ÿ**: Dataset (a list of transactions)
- **f**: Frequency threshold

Steps:

1. For each **k** from 1 to |U|:
2. For every possible itemset **I** of size **k**:

   - Calculate **sup(I)** (support).
   - If **sup(I) â‰¥ f**, add **I** to frequent itemsets.

3. If no itemsets of size **k** are frequent, STOP.

ğŸ§  **Problem**: Checking support for every possible combination is expensive.

---

### **4. Apriori Algorithm â€“ Core Idea**

Avoid checking all combinations by using the **Downward Closure Property**:

> If an itemset is frequent, then **all its subsets** are also frequent.

So:

- Skip generating itemsets that have infrequent subsets.
- Only consider itemsets built from **frequent smaller itemsets**.

---

### **5. Definitions Used**

- **â„±â‚–**: Set of frequent itemsets of size **k**
- **ğ’â‚–**: Set of candidate itemsets of size **k**

---

### **6. Apriori Algorithm â€“ Steps**

Given:

- **U**: Universe of items
- **ğ’Ÿ**: Dataset of transactions
- **f**: Frequency threshold

1. Compute **â„±â‚** (frequent 1-itemsets)
2. For **k = 2 to d** (max itemset size):

   - If **â„±â‚–â‚‹â‚** is empty â†’ break
   - Generate candidate itemsets **ğ’â‚–** from **â„±â‚–â‚‹â‚**
   - For each **I âˆˆ ğ’â‚–**, if **sup(I) â‰¥ f**, add **I** to **â„±â‚–**

3. Return all **frequent itemsets** (the union of all **â„±áµ¢**)

---

### **7. Assumptions**

- **U = {1, 2, ..., d}** (items are numbered)
- Itemsets are ordered subsets of **U**
- Transactions are ordered lexicographically (e.g. {1, 2, 3})

#### **Example Dataset (ordered)**

```
{1, 2, 4}
{1, 3, 4}
{1, 3, 5}
{1, 2, 5}
{2, 2, 3}
```

---

### **8. Downward Closure Property â€“ Details**

Let **I = {jâ‚, jâ‚‚, ..., jâ‚–} âˆˆ â„±â‚–** (a frequent k-itemset). Then:

1. Every subset of size **(kâˆ’1)** is also frequent.
2. **I** can be **created by joining** two itemsets from **â„±â‚–â‚‹â‚**:

   - `{jâ‚, jâ‚‚, ..., jâ‚–â‚‹â‚}` and
   - `{jâ‚, jâ‚‚, ..., jâ‚–â‚‹â‚‚, jâ‚–}`

So:
ğŸ‘‰ We only keep **I** in candidates if it can be formed by joining two valid (kâˆ’1)-itemsets.

---

### **9. Candidate Generation (generate-candidates)**

**Input**:

- **â„±**: Set of frequent itemsets of size **k**
- **k**: Current itemset size

#### **Join Phase**

1. Assume items in **â„±** are ordered
2. For each **I âˆˆ â„±**, where **I = {jâ‚, ..., jâ‚–â‚‹â‚}**:

   - For each **j = jâ‚–â‚‹â‚ + 1 to d**:

     - Create **Iâ€² = {jâ‚, ..., jâ‚–â‚‹â‚‚, j}**
     - If **Iâ€² âˆˆ â„±**, then form candidate **I âˆª {j}** and add to **ğ’**

#### **Prune Phase**

1. For each **I âˆˆ ğ’**:

   - For each **j âˆˆ I**:

     - If **I - {j} âˆ‰ â„±**, remove **I** from ğ’ (since one subset is not frequent)

---

### **10. Example Summary**

- **Frequent itemsets**: itemsets that appear frequently in transactions.
- **Non-frequent itemsets**: do not meet the frequency threshold.
- **Generated candidates**: possible frequent itemsets from joining.
- **Pruned candidates**: removed because some subset was not frequent.

---
