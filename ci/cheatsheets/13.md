---

## üß¨ **Genetic Programming (GP)** ‚Äì Overview

**GP** is a method where computers evolve programs (solutions) automatically using biological ideas like **selection**, **crossover**, and **mutation**.

- Unlike Genetic Algorithms (GAs), GP evolves:

  - The **structure** of the program
  - The **parameters** (constants, variables)

---

## üå≥ **GP Representation**

- Programs are represented as **trees**:

  - **Functions**: in **branches** (e.g., `+`, `*`, `if`, `sin`)
  - **Terminals**: in **leaves** (e.g., constants like 2 or variables like `x`)

- Example expression: $(2 + N) \times 4$

  Tree structure:

  ```
      √ó
     / \
    +   4
   / \
  2   N
  ```

---

## üß± GP Components

| Component            | Description                              | Examples                   |
| -------------------- | ---------------------------------------- | -------------------------- |
| **Terminal Set (T)** | Endpoints of trees (constants/variables) | `2`, `x`, `y`              |
| **Function Set (F)** | Internal nodes (operations or controls)  | `+`, `-`, `*`, `if`, `sin` |

- Function sets should be small (for speed) but expressive enough for the task.

---

## ‚öôÔ∏è GP Operators

### 1. **Selection**

- Choose better programs based on **fitness** to survive or reproduce.

### 2. **Crossover**

- Swap **subtrees** between two parent programs to create offspring.

### 3. **Mutation**

- Randomly change one **function** or **terminal** in a tree.

### GP Loop (Execution Flow)

1. Until new generation is full:

   - Choose to **mutate** or **crossover**
   - If **mutate**: pick 1 individual, randomly alter it
   - If **crossover**: pick 2 individuals, exchange subtrees
   - Add to new generation

2. Repeat for many generations

---

## üå± Tree Initialization Methods

| Method                   | Description                                                                              |
| ------------------------ | ---------------------------------------------------------------------------------------- |
| **Full Method**          | All branches extend to max depth $D_{\text{max}}$; functions inside, terminals at leaves |
| **Grow Method**          | Variable depth trees; functions and terminals mixed at all levels                        |
| **Ramped Half-and-Half** | Combines both Full and Grow to create diverse initial trees                              |

---

## ‚ùå Introns in GP

**Introns**: Parts of the program that do **nothing** (e.g., unused branches like `if` statements that are never true).

Pros and cons:

| ‚úÖ Pros                                        | ‚ùå Cons                                           |
| ---------------------------------------------- | ------------------------------------------------- |
| Protect useful subtrees from harmful crossover | Make programs longer, slower, harder to interpret |

### Controlling Introns

- Use **penalties** based on:

  - Node count
  - Instruction count
  - CPU load

---

## üß† Gene Expression Programming (GEP)

**GEP** uses **fixed-length strings** (like DNA) to encode programs.

| Term          | Description                                     |
| ------------- | ----------------------------------------------- |
| **Genotype**  | Encoded string (e.g., `Q * + - a b c d`)        |
| **Phenotype** | Tree representation after decoding the genotype |

### Decoding Process

- Read string **left-to-right**
- Fill tree **level-by-level**
- Each function uses its required number of inputs

---

## üí° GEP Encoding Example

Math formula:

$$
\sqrt{(a + b) \times (c - d)}
$$

GEP gene string:

```
Q * + - a b c d
```

Tree structure:

```
       Q
       |
       *
     /   \
    +     -
   / \   / \
  a   b c   d
```

---

## ‚ú® GEP Advantages over GP

1. Uses **fixed-length strings**
2. Guarantees **valid programs**
3. Allows **non-coding regions** to absorb mutations/crossovers safely

### Head vs Tail Regions

| Region   | Contains                |
| -------- | ----------------------- |
| **Head** | Functions and terminals |
| **Tail** | Only terminals          |

Example:

```
+ Q - / b * a a Q b a  a b b a
```

---

## üîÅ GEP Mutation Example

Original:

```
+ Q - / b * a a Q **b** a  a b b a
```

Mutation (`b ‚Üí +`, a valid head function):

```
+ Q - / b * a a Q **+** a  a b b a
```

- Changes **tree structure**
- May **increase depth**

---

## üîÄ GEP Crossover Example

| Parent 1                              | Parent 2                              |
| ------------------------------------- | ------------------------------------- |
| `- b + Q b b a b b / a Q b b b a a b` | `/ - a / a b a b b - b a - a b a a a` |

Cut and swap partway:

| Resulting Child 1                     | Resulting Child 2                     |
| ------------------------------------- | ------------------------------------- |
| `- b + / a b a b b - b a - a b a a a` | `/ - a Q b b a b b / a Q b b b a a b` |

- Introduces **diversity**
- Might **disrupt useful structures**

---

## üìä GEP in Symbolic Regression

Target function:

$$
f(a) = a^4 + a^3 + a^2 + a
$$

GEP output:

```
* + + / * * a a a a a a a a
```

Tree:

```
       *
     /   \
    +     +
   / \   / \
  /   * *   a
 a a a a a a
```

Equivalent expression:

$$
(1 + a^2)(a + a^2) = a + a^2 + a^3 + a^4
$$

‚úÖ **Perfect match**

---
