---
# ✅ **Genetic Algorithms – Full Summary**
---

## 🧬 1. Fitness Evaluation and Transformation

### 🔹 **Basic Idea**

- Each candidate solution (chromosome) is given a **fitness value** $f(c_i)$, which determines how good it is.
- Better fitness → higher chance of selection.

### 🔹 **Fitness Calculation**

$$
p_i = \frac{f(c_i)}{\sum_{k=1}^{N} f(c_k)}
$$

### 🔹 **Why Transform Fitness?**

- Raw values might be negative or too close together.
- Can cause:

  - **Close-race**: all individuals look similar → random walk.
  - **Super-individual**: one dominates too early → premature convergence.

---

## 🔹 **Fitness Transformation Schemes**

| Method                  | Description                                                              |
| ----------------------- | ------------------------------------------------------------------------ |
| **Direct Scaling**      | Subtract worst fitness: $f(c_i) = F(c_i) - F_{\text{worst}}$             |
| **Linear Scaling**      | Stretch or shift values: $f(c_i) = aF(c_i) + b$                          |
| **Sigma Truncation**    | Reduce fitness below average: $f(c_i) = \max(0, F(c_i) + \mu - a\sigma)$ |
| **Power Scaling**       | Raise values to power: $f(c_i) = F(c_i)^a$                               |
| **Exponential Scaling** | Use exponential growth: $f(c_i) = \exp\left(\frac{F(c_i)}{a}\right)$     |

---

## 🔹 **Ranking-Based Transformation**

Instead of raw values, use **ranks**.

### 📊 Baker’s Linear Ranking

$$
p_i = \frac{1}{N} \left( \eta_{\text{max}} - (\eta_{\text{max}} - \eta_{\text{min}}) \cdot \frac{i-1}{N-1} \right)
$$

- $\eta_{\text{max}} \in [1,2]$, $\eta_{\text{min}} = 2 - \eta_{\text{max}}$

### Other Ranking Types:

- **Nonlinear ranking**: uses inverse of rank.
- **Geometric**: $p_i = \frac{\eta(1 - \eta)^{i-1}}{c}$
- **Exponential**: $p_i = \frac{1 - e^i}{c}$

---

## 🔁 2. Selection Schemes

| Scheme                  | Description                                      |
| ----------------------- | ------------------------------------------------ |
| **Roulette Wheel**      | Random selection based on fitness (probability)  |
| **Stochastic Sampling** | No or partial replacement reduces repeat picks   |
| **Universal Sampling**  | Picks several at fixed intervals around roulette |
| **k-Tournament**        | Pick k random individuals; keep the best         |

### 📏 Takeover Time

- **Short** → fast domination (high pressure)
- **Long** → slow domination (more exploration)

---

## 🔄 3. Crossover (Recombination)

### 🔹 **Discrete Crossover Types**

| Type         | Description                                     |
| ------------ | ----------------------------------------------- |
| **χ-point**  | Swap at χ crossover points                      |
| **Uniform**  | Pick gene randomly from either parent (50/50)   |
| **Binomial** | Gene from parent1 with prob $p_r$, else parent2 |

- **Small χ**: Low disruption (positional bias)
- **Large χ**: High diversity, risk of instability (distributional bias)

---

### 🔹 **Real-Valued Crossover Types**

| Type                          | Description                                         |
| ----------------------------- | --------------------------------------------------- |
| **Line Arithmetical**         | Offspring between parents: $c = r p_i + (1-r) p_j$  |
| **Intermediate Arithmetical** | Each gene uses a different r                        |
| **Heuristic Arithmetical**    | Extrapolates away from the worse parent             |
| **Simplex Crossover**         | Uses multiple parents, rejects worst, moves from it |

---

## 🧪 4. Mutation

### 🔹 **Discrete (Bit-flipping)**

- Flip bits (0 ↔ 1) with small mutation rate $p_m$
- **Adaptive Mutation**: Adjust based on similarity between parents:

$$
p_m(p_i, p_j) = p_{mL} + (p_{mU} - p_{mL}) \cdot \left( \frac{I(p_i, p_j)}{\text{len}} \right)^2
$$

---

### 🔹 **Real-Valued Mutation**

| Type                     | Description                                        |
| ------------------------ | -------------------------------------------------- |
| **Uniform**              | Random new value within range $[L_k, U_k]$         |
| **Gaussian**             | Small noise from normal distribution               |
| **Adaptive Non-Uniform** | Mutation gets smaller over time (fine-tunes later) |

---

## ⛔ 5. Invalid Chromosomes

### 💣 Causes

- Constraint violation
- Over-expressive encoding or crossover

### ✅ Handling Methods

| Method                | Description                                               |
| --------------------- | --------------------------------------------------------- |
| **Rejection**         | Discard invalid solutions and retry                       |
| **Penalty Functions** | Add penalties to fitness: $F'(x) = F(x) + \text{penalty}$ |
| **Repair**            | Fix invalid solutions directly                            |
| **Special Operators** | Use custom operators to avoid invalid results             |
| **Decoders**          | Chromosome maps to valid solution using external logic    |

---

## 👨‍👩‍👧‍👦 6. Population Models

### 🔹 Generational Model

- Whole population replaced each generation
- Use **elitism** to keep the best

### 🔹 Overlapping / Steady-State Model

- Only a few new individuals replace a few old ones
- Generation gap = $M / N$
- Often includes **no-duplicates rule**

### 🔹 Population Size (N)

- Can be fixed or dynamic
- Often set as $N = 10 \times \text{dimension}$

---

## 🧭 7. Termination Criteria

| Rule                                  | Meaning                           |
| ------------------------------------- | --------------------------------- |
| **Fixed generations**                 | Stop after $t_{max}$ steps        |
| **Best ≈ Average fitness**            | No progress                       |
| **Best hasn’t improved recently**     | Stalled                           |
| **Low diversity**                     | Population is too similar         |
| **Mathematical condition** (e.g. KKT) | Optimization conditions satisfied |

---

## 🌐 8. Parallel Populations

### 🔹 Fine-Grained (Cellular)

- Individuals on a grid
- Interact with neighbors only

### 🔹 Coarse-Grained (Island Model)

- Multiple subpopulations (islands)
- Occasionally exchange individuals (migration)

**Benefits:**

- Prevents premature convergence
- Solves multimodal problems well

---

## 🌱 9. Hybridisation

| Strategy                     | Description                                            |
| ---------------------------- | ------------------------------------------------------ |
| **Smart initial population** | Use known good solutions                               |
| **Custom operators**         | Tailored to encoding/problem                           |
| **Post-GA local search**     | Apply gradient descent or similar after GA finishes    |
| **Memetic GA**               | Apply local search during evolution                    |
| **Lamarckian Model**         | Improvements passed to offspring                       |
| **Baldwinian Model**         | Offspring learn faster but don’t inherit direct traits |

---

## 🧭 10. Niching & Diversity

### Purpose:

- **Find multiple good solutions** (multimodal optimization)
- Prevent population collapse into one peak

### Key Idea: **Fitness Sharing**

- Share fitness among similar individuals to avoid crowding

$$
F_{\text{shared}}(p_i) = \frac{F(p_i)^b}{\sum_{j=1}^{N} \gamma(d(p_i, p_j))}
$$

Where:

$$
\gamma(d) = \max \left[0, 1 - \left( \frac{d}{\sigma_{\text{share}}} \right)^a \right]
$$

- $\sigma_{\text{share}}$: niche radius
- $d(p_i, p_j)$: distance between individuals

---
